#!/usr/bin/env python
import datapackage
import os
import sys
import codecs
import unicodecsv as csv
from jsontableschema import infer
import glob
import json
from collections import OrderedDict

'''
- do we have a data/ directory?
- does it have CSV files?
- does it have JSON files?
- does it have files with other types?
'''

from colorama import init, Fore, Back, Style
init(autoreset=True)


# ensure we get the output in fixed order by specifying the descriptor argument
dp = datapackage.DataPackage(descriptor=OrderedDict())

# Splash screen :3
print Fore.YELLOW + "   ___    ___  "
print Fore.YELLOW + "   \__\__/__/  " + Fore.RESET + "Datapaka!"
print Fore.YELLOW + "   | ._. |  |  " + Fore.RESET + "Let's package this data!"
print Fore.YELLOW + "   |_____|__|  "
print

# Does data/ exist?
if not os.path.exists('data') or not os.path.isdir('data'):
    print "The data/ directory does not exist, can't do much here."
    print "Please create it and place some CSV files inside, then call me again."
    print
    sys.exit()

# Does datapackage.json exist?
if os.path.exists('datapackage.json'):
    print "There already is a datapackage.json file here."
    print "I will save the result of this in " + Style.BRIGHT + "datapackage-new.json" + Style.RESET_ALL + "."
    print

# Title
print "What's the " + Style.BRIGHT + "title" + Style.RESET_ALL + " for this data package?"
print Style.DIM + "A title is a concise descriptor of what's in the data package, in human terms. 'Housing Prices in Berlin' or 'World Population Density' are good titles. (optional field)"
"What's the " + Style.BRIGHT + "title" + Style.RESET_ALL + " for this data package?"
dp.descriptor['title'] = raw_input(Style.BRIGHT + "? ")

# Slug ("name" field)
default_slug = dp.descriptor['title'].lower().replace(' ', '-')
print "What's the " + Style.BRIGHT + "slug" + Style.RESET_ALL + " for this data package? [Leave blank for '%s']" % default_slug
print Style.DIM + "A slug ('name' field) is a lower-case, no spaces version of the title. Use hyphens or underscores instead of spaces. 'berlin-housing-prices' or 'world-population-density' are good slugs."
dp.descriptor['name'] = raw_input(Style.BRIGHT + "? ") or default_slug

# Description
print "Give me a short, human " + Style.BRIGHT + "description" + Style.RESET_ALL + " for this data package."
print Style.DIM + "A description gives more information about what's inside. 'Property prices in Berlin in April 2015' or 'UN population density statistics for the 2003-2013 period' let people know more specific details. Markdown formatting can be used. (optional field)"
dp.descriptor['description'] = raw_input(Style.BRIGHT + "? ")

# Version
default_version = "0.1.0"
print "What's the package " + Style.BRIGHT + "version number" + Style.RESET_ALL + "? [Leave blank for '%s']" % default_version
print Style.DIM + "The version number tracks changes and improvements on the data package. If you're starting a new one, go with the default value of 0.1.0, and update it whenever there is a change in the data layout."
dp.descriptor['version'] = raw_input(Style.BRIGHT + "? ") or default_version

# Homepage
print "What's the " + Style.BRIGHT + "homepage" + Style.RESET_ALL + " for this data package?"
print Style.DIM + "Please include the 'http://' prefix. (optional field)"
h = raw_input(Style.BRIGHT + "? ")
if h:
    dp.descriptor['homepage'] = h

# License
default_license = "1"
license_options = {
    "1": "ODC-PDDL-1.0",
    "2": "ODbL-1.0",
    "3": "ODC-BY-1.0",
    "4": "CC0-1.0",
    "5": "CC-BY-4.0",
    "6": "CC-BY-SA-4.0",
}
print "What's the package " + Style.BRIGHT + "license" + Style.RESET_ALL + "? [Leave blank for '%s'] " % default_license
print Style.DIM + "The license field states the license under which this package is to be published. Read more about each license at http://opendefinition.org/licenses/."
print
print('1) Public Domain Dedication and License (public domain)')
print('2) Open Database License (attribution, sharealike)')
print('3) Open Data Commons Attribution License (attribution)')
print('4) Creative Commons Zero (public domain)')
print('5) Creative Commons Attribution')
print('6) Creative Commons Attribution-ShareAlike')
selected = raw_input(Style.BRIGHT + "? ") or default_license
dp.descriptor['license'] = license_options[selected.strip()]

# Sources
dp.descriptor['sources'] = []
another = True
print "Now I want to know about the " + Style.BRIGHT + "sources" + Style.RESET_ALL + " of your data."
print Style.DIM + "I will ask you the name and URL for each, and then you'll be asked if you want to input another source or move ahead."
while another:
    source_name = raw_input(Style.BRIGHT + "Source name? ")
    source_url = raw_input(Style.BRIGHT + "Source URL? ")
    dp.descriptor['sources'].append({"name": source_name, "web": source_url})
    print
    add_another = raw_input(Style.BRIGHT + "Add another source? [n]")
    if add_another not in ("y", "Y"):
        another = False

# Contributors
dp.descriptor['contributors'] = []
another = True
print "Now I want to know about the " + Style.BRIGHT + "contributors" + Style.RESET_ALL + " of this data package."
print Style.DIM + "I will ask you the name, e-mail and website URL for each, and then you'll be asked if you want to input another contributor or move ahead."
while another:
    contrib_name = raw_input(Style.BRIGHT + "Contributor name? ")
    contrib_email = raw_input(Style.BRIGHT + "Contributor e-mail (optional)? ")
    contrib_url = raw_input(Style.BRIGHT + "Contributor URL (optional)? ")
    c = {"name": contrib_name}
    if contrib_email:
        c["email"] = contrib_email
    if contrib_url:
        c["web"] = contrib_url
    dp.descriptor['contributors'].append(c)
    print
    add_another = raw_input(Style.BRIGHT + "Add another contributor? [n]")
    if add_another not in ("y", "Y"):
        another = False

# Keywords
print "Tell me some " + Style.BRIGHT + "keywords" + Style.RESET_ALL + " (tags) for this package so that users can find it in catalogs. [optional]"
print Style.DIM + "Keywords can have spaces; separate distinct keywords with commas."
k = raw_input(Style.BRIGHT + "? ")
if k:
    dp.descriptor['keywords'] = [w.strip() for w in k.split(",")]


# CSV files
dp.descriptor['resources'] = []
csv_files = glob.glob('data/*.csv')
print
if len(csv_files) == 1:
    print "Found a single CSV file in the data/ dir. Easy!"
elif len(csv_files) != 0:
    print "Found %d CSV files in the data/ dir." % len(csv_files)
else:
    print "No CSV files found! I currently can't handle anything other than CSV. They'll fix me soon!"

for filepath in csv_files:
    print
    print "Let's now look at " + Style.BRIGHT + filepath + Style.RESET_ALL + "..."
    default_slug = filepath.split("/")[-1].split(".")[0]
    slug = raw_input("  Slug for this file? [%s]" % default_slug)
    resource_name = slug or default_slug
    with open(filepath, 'rb') as f:
        headers = [s.decode("utf-8") for s in f.readline().rstrip('\n').split(',')]
        values = csv.reader(f, encoding="utf-8")
        print "  Inferring column types, this might take a bit..."
        schema = infer(headers, values)
        fields = []
        for field in schema['fields']:
            fieldname = field['name']
            print type(fieldname)
            field['title'] = raw_input("  Human title for field '%s'? " % fieldname)
            field['description'] = raw_input("  Short description for field '%s'? " % fieldname)
            fields.append(field)

        dp.descriptor['resources'].append(
            {
                'name': resource_name,
                'path': filepath,
                'schema': fields
            }
        )

out = json.dumps(dp.to_dict(), ensure_ascii=False, encoding='utf-8', indent=2)

if not os.path.exists('datapackage.json'):
    outfilename = 'datapackage.json'
else:
    outfilename = 'datapackage-new.json'
with codecs.open(outfilename, 'w', 'utf-8') as f:
    f.write(out)

print "All done! File saved as " + Style.BRIGHT + outfilename + Style.RESET_ALL + ". Ta!"
